:stem:

= Конечные автоматы и регулярные языки

== Конечные автоматы и регулярные языки, их эквивалентность

Конечный автомат (машина состояний) -- это абстрактное дискретное устройство, имеющее один вход и один выход, и в каждый момент времени находящееся в одном из возможных состояний, количество которых конечно.
Конечный автомат задается пятеркой \$<\Sigma, Q, s \in Q, T \subset Q, \delta: Q \times \Sigma \leftarrow Q>\$, где \$\Sigma\$ - алфавит, \$Q\$ - множество состояний, \$s\$ - начальное состояние, \$T\$ - множество допускающих состояний, \$\sigma\$ - функция переходов.
Конечному автомату можно поставить в соответствие допускаемый им язык -- множество слов, чтение которых переводит автомат из начального состояния в одно из конечных.

Регулярный язык над конечным алфавитом \$\Sigma\$ -- множество слов, определяемое по индукции:

- Пустое множество является регулярным языком
- Множество из одной строки является регулярным языком
- Множество из одного однобуквенного слова является регулярным языком
- Объединение, конкатенация и замыкание Клини регулярных языков является регулярным языком

*Теорема Клини* утверждает, что классы регулярных языков и языков, допускаемых конечным автоматов совпадают.
Доказательство:

- По регулярному языку можно построить автомат: по индукции.
- По КА можно построить регулярный язык: алгоритм построения тривиален.

== Детерминизация автоматов

Конечный автомат называется недетерминированным, если по одному символу из одного состояния возможны несколько переходов, и детерминированным - если только один.
По недетерминированному КА можно построить эквивалентный детерминированный с помощью алгоритма Томпсона:

Алгоритм Томпсона использует поиск в ширину, чтобы перебрать все состояния НКА, объединяет достижимые одним и тем же символом и удаляет \$\epsilon\$-переходы (переходы из состояния в само себя).
Асимптотика \$O(n 2^n)\$

https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D0%9D%D0%9A%D0%90_%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A2%D0%BE%D0%BC%D0%BF%D1%81%D0%BE%D0%BD%D0%B0[подробное описание и доказательство]

== Минимизация автоматов

=== Простой алгоритм

Идея простого алгоритма минимизации автомата (поиска такого автомата, эквивалентного данному, число состояний которого минимально) состоит в том, чтобы разбить все его состояния на классы эквивалентности, которые и будут состояниями минимизированного автомата.
Асимптотика \$O(n^2)\$
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B7%D0%B0_O(n%5E2)_%D1%81_%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%BF%D0%B0%D1%80_%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%BC%D1%8B%D1%85_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9#.D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5[подробное описание]

=== Алгоритм Хопкрофта

Алгоритм Хопкрофта является оптимизацией простого алгоритма, основанной на лемме:

Класс \$R = R1 \cup R2\$ и \$R1 \cap  R2 = \varnothing\$, тогда разбиение классов по символу \$a\$ любыми двумя классами из \$R\$, \$R1\$, \$R2\$ эквивалентно разбиению классов по символу \$a\$ всеми тремя классами \$R\$, \$R1\$, \$R2\$.

https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%94%D0%9A%D0%90,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A5%D0%BE%D0%BF%D0%BA%D1%80%D0%BE%D1%84%D1%82%D0%B0_(%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_O(n_log_n))#.D0.90.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC_.D0.A5.D0.BE.D0.BF.D0.BA.D1.80.D0.BE.D1.84.D1.82.D0.B0[подробное описание, доказательство и реализация]

=== Алгоритм Бржозвского

*Теорема Бржовского:*
Пусть A - конечный автомат, d(A) - детерминизированный конечный автомат, r(A) - обратный автомат для A. Тогда минимальный автомат для A может быть получен как drdr(A).

Алгоритм Бржовского работает в том числе с недетерминированными конечными автоматами.
В худшем случае обладает экспоненциальной сложностью, но на практике нередко превосходит алгоритм Хопкрофта (в частности для автоматов с большим числом переходов).

https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D1%80%D0%B6%D0%BE%D0%B7%D0%BE%D0%B2%D1%81%D0%BA%D0%BE%D0%B3%D0%BE#.D0.90.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC[подробное описание, доказательство и пример]